// Copyright (c) 2005-2017 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "basetypes.h"

namespace GroupPolicy
{
  namespace PolicyDefinitions
  {
    // GUID
    // 


    // VersionString
    // 


    // StringReference
    // 


    // PresentationReference
    // 


    // ResourceID
    // 


    // Annotation
    // 

    const ::xercesc::DOMElement& Annotation::
    any () const
    {
      return this->any_.get ();
    }

    ::xercesc::DOMElement& Annotation::
    any ()
    {
      return this->any_.get ();
    }

    void Annotation::
    any (const ::xercesc::DOMElement& e)
    {
      this->any_.set (e);
    }

    void Annotation::
    any (::xercesc::DOMElement* e)
    {
      this->any_.set (e);
    }

    const Annotation::ApplicationType& Annotation::
    application () const
    {
      return this->application_.get ();
    }

    Annotation::ApplicationType& Annotation::
    application ()
    {
      return this->application_.get ();
    }

    void Annotation::
    application (const ApplicationType& x)
    {
      this->application_.set (x);
    }

    void Annotation::
    application (::std::unique_ptr< ApplicationType > x)
    {
      this->application_.set (std::move (x));
    }

    const ::xercesc::DOMDocument& Annotation::
    dom_document () const
    {
      return *this->dom_document_;
    }

    ::xercesc::DOMDocument& Annotation::
    dom_document ()
    {
      return *this->dom_document_;
    }


    // ItemName
    // 


    // ItemReference
    // 


    // LocalizedString
    // 

    const LocalizedString::IdType& LocalizedString::
    id () const
    {
      return this->id_.get ();
    }

    LocalizedString::IdType& LocalizedString::
    id ()
    {
      return this->id_.get ();
    }

    void LocalizedString::
    id (const IdType& x)
    {
      this->id_.set (x);
    }

    void LocalizedString::
    id (::std::unique_ptr< IdType > x)
    {
      this->id_.set (std::move (x));
    }


    // RegistryKey
    // 


    // RegistryValueName
    // 


    // FileName
    // 
  }
}

#include <xsd/cxx/xml/dom/wildcard-source.hxx>

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace GroupPolicy
{
  namespace PolicyDefinitions
  {
    // GUID
    //

    GUID::
    GUID ()
    : ::xml_schema::String ()
    {
    }

    GUID::
    GUID (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    GUID::
    GUID (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    GUID::
    GUID (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    GUID::
    GUID (const GUID& x,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    GUID::
    GUID (const ::xercesc::DOMElement& e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    GUID::
    GUID (const ::xercesc::DOMAttr& a,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    GUID::
    GUID (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::Flags f,
          ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    GUID* GUID::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class GUID (*this, f, c);
    }

    GUID::
    ~GUID ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, GUID >
    _xsd_GUID_type_factory_init (
      "GUID",
      "http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions");

    // VersionString
    //

    VersionString::
    VersionString ()
    : ::xml_schema::Token ()
    {
    }

    VersionString::
    VersionString (const char* _xsd_Token_base)
    : ::xml_schema::Token (_xsd_Token_base)
    {
    }

    VersionString::
    VersionString (const ::std::string& _xsd_Token_base)
    : ::xml_schema::Token (_xsd_Token_base)
    {
    }

    VersionString::
    VersionString (const ::xml_schema::Token& _xsd_Token_base)
    : ::xml_schema::Token (_xsd_Token_base)
    {
    }

    VersionString::
    VersionString (const VersionString& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Token (x, f, c)
    {
    }

    VersionString::
    VersionString (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Token (e, f, c)
    {
    }

    VersionString::
    VersionString (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Token (a, f, c)
    {
    }

    VersionString::
    VersionString (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::Token (s, e, f, c)
    {
    }

    VersionString* VersionString::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class VersionString (*this, f, c);
    }

    VersionString::
    ~VersionString ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, VersionString >
    _xsd_VersionString_type_factory_init (
      "versionString",
      "http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions");

    // StringReference
    //

    StringReference::
    StringReference ()
    : ::xml_schema::String ()
    {
    }

    StringReference::
    StringReference (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    StringReference::
    StringReference (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    StringReference::
    StringReference (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    StringReference::
    StringReference (const StringReference& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    StringReference::
    StringReference (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    StringReference::
    StringReference (const ::xercesc::DOMAttr& a,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    StringReference::
    StringReference (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    StringReference* StringReference::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class StringReference (*this, f, c);
    }

    StringReference::
    ~StringReference ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, StringReference >
    _xsd_StringReference_type_factory_init (
      "stringReference",
      "http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions");

    // PresentationReference
    //

    PresentationReference::
    PresentationReference ()
    : ::xml_schema::String ()
    {
    }

    PresentationReference::
    PresentationReference (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    PresentationReference::
    PresentationReference (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    PresentationReference::
    PresentationReference (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    PresentationReference::
    PresentationReference (const PresentationReference& x,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    PresentationReference::
    PresentationReference (const ::xercesc::DOMElement& e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    PresentationReference::
    PresentationReference (const ::xercesc::DOMAttr& a,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    PresentationReference::
    PresentationReference (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::Flags f,
                           ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    PresentationReference* PresentationReference::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class PresentationReference (*this, f, c);
    }

    PresentationReference::
    ~PresentationReference ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, PresentationReference >
    _xsd_PresentationReference_type_factory_init (
      "presentationReference",
      "http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions");

    // ResourceID
    //

    ResourceID::
    ResourceID ()
    : ::xml_schema::String ()
    {
    }

    ResourceID::
    ResourceID (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    ResourceID::
    ResourceID (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    ResourceID::
    ResourceID (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    ResourceID::
    ResourceID (const ResourceID& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    ResourceID::
    ResourceID (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    ResourceID::
    ResourceID (const ::xercesc::DOMAttr& a,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    ResourceID::
    ResourceID (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    ResourceID* ResourceID::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ResourceID (*this, f, c);
    }

    ResourceID::
    ~ResourceID ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ResourceID >
    _xsd_ResourceID_type_factory_init (
      "resourceID",
      "http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions");

    // Annotation
    //

    Annotation::
    Annotation (const ::xercesc::DOMElement& any,
                const ApplicationType& application)
    : ::xml_schema::Type (),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      any_ (any, this->dom_document ()),
      application_ (application, this)
    {
    }

    Annotation::
    Annotation (const Annotation& x,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (x, f, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      any_ (x.any_, this->dom_document ()),
      application_ (x.application_, f, this)
    {
    }

    Annotation::
    Annotation (const ::xercesc::DOMElement& e,
                ::xml_schema::Flags f,
                ::xml_schema::Container* c)
    : ::xml_schema::Type (e, f | ::xml_schema::Flags::base, c),
      dom_document_ (::xsd::cxx::xml::dom::create_document< char > ()),
      any_ (this->dom_document ()),
      application_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
        this->parse (p, f);
      }
    }

    void Annotation::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      for (; p.more_content (); p.next_content (false))
      {
        const ::xercesc::DOMElement& i (p.cur_element ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        // any
        //
        if (true)
        {
          if (!any_.present ())
          {
            ::xercesc::DOMElement* r (
              static_cast< ::xercesc::DOMElement* > (
                this->dom_document ().importNode (
                  const_cast< ::xercesc::DOMElement* > (&i), true)));
            this->any_.set (r);
            continue;
          }
        }

        break;
      }

      if (!any_.present ())
      {
        throw ::xsd::cxx::tree::expected_element< char > (
          "*",
          "##any");
      }

      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "application" && n.namespace_ ().empty ())
        {
          this->application_.set (ApplicationTraits::create (i, f, this));
          continue;
        }
      }

      if (!application_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "application",
          "");
      }
    }

    Annotation* Annotation::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class Annotation (*this, f, c);
    }

    Annotation& Annotation::
    operator= (const Annotation& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::Type& > (*this) = x;
        this->any_ = x.any_;
        this->application_ = x.application_;
      }

      return *this;
    }

    Annotation::
    ~Annotation ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, Annotation >
    _xsd_Annotation_type_factory_init (
      "Annotation",
      "http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions");

    // ItemName
    //

    ItemName::
    ItemName ()
    : ::xml_schema::String ()
    {
    }

    ItemName::
    ItemName (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    ItemName::
    ItemName (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    ItemName::
    ItemName (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    ItemName::
    ItemName (const ItemName& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    ItemName::
    ItemName (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    ItemName::
    ItemName (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    ItemName::
    ItemName (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    ItemName* ItemName::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ItemName (*this, f, c);
    }

    ItemName::
    ~ItemName ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ItemName >
    _xsd_ItemName_type_factory_init (
      "itemName",
      "http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions");

    // ItemReference
    //

    ItemReference::
    ItemReference ()
    : ::xml_schema::String ()
    {
    }

    ItemReference::
    ItemReference (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    ItemReference::
    ItemReference (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    ItemReference::
    ItemReference (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    ItemReference::
    ItemReference (const ItemReference& x,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    ItemReference::
    ItemReference (const ::xercesc::DOMElement& e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    ItemReference::
    ItemReference (const ::xercesc::DOMAttr& a,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    ItemReference::
    ItemReference (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::Flags f,
                   ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    ItemReference* ItemReference::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class ItemReference (*this, f, c);
    }

    ItemReference::
    ~ItemReference ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, ItemReference >
    _xsd_ItemReference_type_factory_init (
      "itemReference",
      "http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions");

    // LocalizedString
    //

    LocalizedString::
    LocalizedString (const IdType& id)
    : ::xml_schema::String (),
      id_ (id, this)
    {
    }

    LocalizedString::
    LocalizedString (const char* _xsd_String_base,
                     const IdType& id)
    : ::xml_schema::String (_xsd_String_base),
      id_ (id, this)
    {
    }

    LocalizedString::
    LocalizedString (const ::std::string& _xsd_String_base,
                     const IdType& id)
    : ::xml_schema::String (_xsd_String_base),
      id_ (id, this)
    {
    }

    LocalizedString::
    LocalizedString (const ::xml_schema::String& _xsd_String_base,
                     const IdType& id)
    : ::xml_schema::String (_xsd_String_base),
      id_ (id, this)
    {
    }

    LocalizedString::
    LocalizedString (const LocalizedString& x,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c),
      id_ (x.id_, f, this)
    {
    }

    LocalizedString::
    LocalizedString (const ::xercesc::DOMElement& e,
                     ::xml_schema::Flags f,
                     ::xml_schema::Container* c)
    : ::xml_schema::String (e, f | ::xml_schema::Flags::base, c),
      id_ (this)
    {
      if ((f & ::xml_schema::Flags::base) == 0)
      {
        ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
        this->parse (p, f);
      }
    }

    void LocalizedString::
    parse (::xsd::cxx::xml::dom::parser< char >& p,
           ::xml_schema::Flags f)
    {
      while (p.more_attributes ())
      {
        const ::xercesc::DOMAttr& i (p.next_attribute ());
        const ::xsd::cxx::xml::qualified_name< char > n (
          ::xsd::cxx::xml::dom::name< char > (i));

        if (n.name () == "id" && n.namespace_ ().empty ())
        {
          this->id_.set (IdTraits::create (i, f, this));
          continue;
        }
      }

      if (!id_.present ())
      {
        throw ::xsd::cxx::tree::expected_attribute< char > (
          "id",
          "");
      }
    }

    LocalizedString* LocalizedString::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class LocalizedString (*this, f, c);
    }

    LocalizedString& LocalizedString::
    operator= (const LocalizedString& x)
    {
      if (this != &x)
      {
        static_cast< ::xml_schema::String& > (*this) = x;
        this->id_ = x.id_;
      }

      return *this;
    }

    LocalizedString::
    ~LocalizedString ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, LocalizedString >
    _xsd_LocalizedString_type_factory_init (
      "LocalizedString",
      "http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions");

    // RegistryKey
    //

    RegistryKey::
    RegistryKey ()
    : ::xml_schema::String ()
    {
    }

    RegistryKey::
    RegistryKey (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    RegistryKey::
    RegistryKey (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    RegistryKey::
    RegistryKey (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    RegistryKey::
    RegistryKey (const RegistryKey& x,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    RegistryKey::
    RegistryKey (const ::xercesc::DOMElement& e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    RegistryKey::
    RegistryKey (const ::xercesc::DOMAttr& a,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    RegistryKey::
    RegistryKey (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::Flags f,
                 ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    RegistryKey* RegistryKey::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class RegistryKey (*this, f, c);
    }

    RegistryKey::
    ~RegistryKey ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, RegistryKey >
    _xsd_RegistryKey_type_factory_init (
      "registryKey",
      "http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions");

    // RegistryValueName
    //

    RegistryValueName::
    RegistryValueName ()
    : ::xml_schema::String ()
    {
    }

    RegistryValueName::
    RegistryValueName (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    RegistryValueName::
    RegistryValueName (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    RegistryValueName::
    RegistryValueName (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    RegistryValueName::
    RegistryValueName (const RegistryValueName& x,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    RegistryValueName::
    RegistryValueName (const ::xercesc::DOMElement& e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    RegistryValueName::
    RegistryValueName (const ::xercesc::DOMAttr& a,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    RegistryValueName::
    RegistryValueName (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::Flags f,
                       ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    RegistryValueName* RegistryValueName::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class RegistryValueName (*this, f, c);
    }

    RegistryValueName::
    ~RegistryValueName ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, RegistryValueName >
    _xsd_RegistryValueName_type_factory_init (
      "registryValueName",
      "http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions");

    // FileName
    //

    FileName::
    FileName ()
    : ::xml_schema::String ()
    {
    }

    FileName::
    FileName (const char* _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    FileName::
    FileName (const ::std::string& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    FileName::
    FileName (const ::xml_schema::String& _xsd_String_base)
    : ::xml_schema::String (_xsd_String_base)
    {
    }

    FileName::
    FileName (const FileName& x,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (x, f, c)
    {
    }

    FileName::
    FileName (const ::xercesc::DOMElement& e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (e, f, c)
    {
    }

    FileName::
    FileName (const ::xercesc::DOMAttr& a,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (a, f, c)
    {
    }

    FileName::
    FileName (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::Flags f,
              ::xml_schema::Container* c)
    : ::xml_schema::String (s, e, f, c)
    {
    }

    FileName* FileName::
    _clone (::xml_schema::Flags f,
            ::xml_schema::Container* c) const
    {
      return new class FileName (*this, f, c);
    }

    FileName::
    ~FileName ()
    {
    }

    static
    const ::xsd::cxx::tree::type_factory_initializer< 0, char, FileName >
    _xsd_FileName_type_factory_init (
      "fileName",
      "http://schemas.microsoft.com/GroupPolicy/2006/07/PolicyDefinitions");
  }
}

#include <ostream>

#include <xsd/cxx/tree/std-ostream-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::std_ostream_plate< 0, char >
  std_ostream_plate_init;
}

namespace GroupPolicy
{
  namespace PolicyDefinitions
  {
    ::std::ostream&
    operator<< (::std::ostream& o, const GUID& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, GUID >
    _xsd_GUID_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const VersionString& i)
    {
      o << static_cast< const ::xml_schema::Token& > (i);

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, VersionString >
    _xsd_VersionString_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const StringReference& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, StringReference >
    _xsd_StringReference_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const PresentationReference& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, PresentationReference >
    _xsd_PresentationReference_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const ResourceID& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ResourceID >
    _xsd_ResourceID_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const Annotation& i)
    {
      o << ::std::endl << "application: " << i.application ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, Annotation >
    _xsd_Annotation_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const ItemName& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ItemName >
    _xsd_ItemName_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const ItemReference& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, ItemReference >
    _xsd_ItemReference_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const LocalizedString& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      o << ::std::endl << "id: " << i.id ();
      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, LocalizedString >
    _xsd_LocalizedString_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const RegistryKey& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, RegistryKey >
    _xsd_RegistryKey_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const RegistryValueName& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, RegistryValueName >
    _xsd_RegistryValueName_std_ostream_init;

    ::std::ostream&
    operator<< (::std::ostream& o, const FileName& i)
    {
      o << static_cast< const ::xml_schema::String& > (i);

      return o;
    }

    static
    const ::xsd::cxx::tree::std_ostream_initializer< 0, char, FileName >
    _xsd_FileName_std_ostream_init;
  }
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace GroupPolicy
{
  namespace PolicyDefinitions
  {
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

